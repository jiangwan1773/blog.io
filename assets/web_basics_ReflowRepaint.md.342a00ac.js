import{_ as o,C as c,c as s,H as a,Q as l,o as t}from"./chunks/framework.c3d9f2ac.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"web/basics/ReflowRepaint.md","filePath":"web/basics/ReflowRepaint.md"}'),d={name:"web/basics/ReflowRepaint.md"},n=l('<blockquote><p>核心就是<code>&lt;iframe /&gt;</code>标签；只有pdf是可以直接被预览的，word格式需要使用做拼接</p></blockquote><h2 id="知识补充" tabindex="-1">知识补充 <a class="header-anchor" href="#知识补充" aria-label="Permalink to &quot;知识补充&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title"><code>回流必将引起重绘，重绘不一定会引起回流</code></p><br> 1.浏览器使用流式布局模型 (Flow Based Layout)<br> 2.浏览器会把`HTML`解析成`DOM`，把`CSS`解析成`CSSOM`，`DOM`和`CSSOM`合并就产生了`Render` `Tree`。<br> 3.有了`RenderTree`，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。<br> 4.由于浏览器使用流式布局，对`Render Tree`的计算通常只需要遍历一次就可以完成，但`table`及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用`table`布局的原因之一。 </div><h2 id="回流-reflow" tabindex="-1">回流 (Reflow) <a class="header-anchor" href="#回流-reflow" aria-label="Permalink to &quot;回流 (Reflow)&quot;">​</a></h2><blockquote><p>也叫重排</p></blockquote><div class="info custom-block"><p class="custom-block-title">当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p><blockquote><p>会导致回流的操作：</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">1.页面首次渲染</span></span>\n<span class="line"><span style="color:#E1E4E8;">2.浏览器窗口大小发生改变</span></span>\n<span class="line"><span style="color:#E1E4E8;">3.元素尺寸或位置发生改变</span></span>\n<span class="line"><span style="color:#E1E4E8;">4.元素内容变化（文字数量或图片大小等等）</span></span>\n<span class="line"><span style="color:#E1E4E8;">5.元素字体大小变化</span></span>\n<span class="line"><span style="color:#E1E4E8;">6.添加或者删除可见的DOM元素</span></span>\n<span class="line"><span style="color:#E1E4E8;">7.激活CSS伪类（例如：:hover）</span></span>\n<span class="line"><span style="color:#E1E4E8;">8.查询某些属性或调用某些方法</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">1.页面首次渲染</span></span>\n<span class="line"><span style="color:#24292E;">2.浏览器窗口大小发生改变</span></span>\n<span class="line"><span style="color:#24292E;">3.元素尺寸或位置发生改变</span></span>\n<span class="line"><span style="color:#24292E;">4.元素内容变化（文字数量或图片大小等等）</span></span>\n<span class="line"><span style="color:#24292E;">5.元素字体大小变化</span></span>\n<span class="line"><span style="color:#24292E;">6.添加或者删除可见的DOM元素</span></span>\n<span class="line"><span style="color:#24292E;">7.激活CSS伪类（例如：:hover）</span></span>\n<span class="line"><span style="color:#24292E;">8.查询某些属性或调用某些方法</span></span></code></pre></div><blockquote><p>一些常用且会导致回流的属性和方法： <br><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code><br><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code><br><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code><br><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code><br><code>getComputedStyle()</code><br><code>getBoundingClientRect()</code><br><code>scrollTo()</code></p></blockquote></div><h2 id="重绘-repaint" tabindex="-1">重绘 (Repaint) <a class="header-anchor" href="#重绘-repaint" aria-label="Permalink to &quot;重绘 (Repaint)&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘</p></div><h2 id="性能影响" tabindex="-1">性能影响 <a class="header-anchor" href="#性能影响" aria-label="Permalink to &quot;性能影响&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">回流比重绘的代价要更高</p><p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。<br></p><p>现代浏览器会对频繁的回流或重绘操作进行优化：<br></p><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。<br></p><p>当你访问以下属性或方法时，浏览器会立刻清空队列：<br></p><p><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code><br><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code><br><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code><br><code>width</code>、<code>height</code><br><code>getComputedStyle()</code><br><code>getBoundingClientRect()</code><br></p><p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p></div><h2 id="如何避免" tabindex="-1">如何避免 <a class="header-anchor" href="#如何避免" aria-label="Permalink to &quot;如何避免&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">CSS</p><p>避免使用<code>table</code>布局。<br> 尽可能在<code>DOM</code>树的最末端改变<code>class</code>。<br> 避免设置多层内联样式。<br> 将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。<br> 避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。<br></p></div><div class="info custom-block"><p class="custom-block-title">JavaScript</p><p>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。<br> 避免频繁操作DOM，创建一个<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中。<br> 也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。<br> 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。<br> 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</p></div>',13);function p(i,r,b,h,f,u){const e=c("c-title");return t(),s("div",null,[a(e,{title:"浏览器的回流与重绘"}),n])}const k=o(d,[["render",p]]);export{E as __pageData,k as default};
